theory root 

val versionOfProofScript = "0.5.0.2"

let trueDef: 'true = ((p : â„™ â†¦ p) = (p â†¦ p))'
let falseDef: 'false = (âˆ€ p. p)'
let andDef: 'and = (x y â†¦ ((f â†¦ (f x y) : â„™) = (f â†¦ f âŠ¤ âŠ¤)))'
let notDef: 'not = (p â†¦ (p â†’ âŠ¥))'
let orDef: 'or = (x y â†¦ (âˆ€ z. (x â†’ z) â†’ (y â†’ z) â†’ z))'

let 'empty'
let 'difference : ğ’° â†’ ğ’° â†’ ğ’°'
let 'union : ğ’° â†’ ğ’° â†’ ğ’°'
let 'Union : ğ’° â†’ ğ’°'
let 'intersection : ğ’° â†’ ğ’° â†’ ğ’°'
let 'Intersection : ğ’° â†’ ğ’°'
let 'power : ğ’° â†’ ğ’°'
let 'singleton : ğ’° â†’ ğ’°'
let 'sep : ğ’° â†’ (ğ’° â†’ â„™) â†’ ğ’°'
let 'repl : ğ’° â†’ (ğ’° â†’ ğ’°) â†’ ğ’°'
let 'elementof : ğ’° â†’ ğ’° â†’ â„™'
let 'subsetof : ğ’° â†’ ğ’° â†’ â„™'
let 'pair : ğ’° â†’ ğ’° â†’ ğ’°'
let 'fun : ğ’° â†’ (ğ’° â†’ ğ’°) â†’ ğ’°'
let 'apply : ğ’° â†’ ğ’° â†’ ğ’°'
let 'forallin : ğ’° â†’ (ğ’° â†’ â„™) â†’ â„™'
let 'existsin : ğ’° â†’ (ğ’° â†’ â„™) â†’ â„™'

assume empty: 'âˆ€ x. x âˆ‰ âˆ…'
assume ext: 'âˆ€ x, y. (x = y) = (âˆ€ z. z âˆˆ x = z âˆˆ y)'
assume bigUnion: 'âˆ€ z, x. z âˆˆ â‹ƒ x = (âˆƒ y âˆˆ x. z âˆˆ y)'
assume union: 'âˆ€ x, y, z. (z âˆˆ x âˆª y) = (z âˆˆ x âˆ¨ z âˆˆ y)'
assume bigIntersection: 'âˆ€ z, x. x â‰  âˆ… â†’ z âˆˆ â‹‚ x = (âˆ€ y âˆˆ x. z âˆˆ y)'
assume intersection: 'âˆ€ x, y, z. z âˆˆ x âˆ© y = (z âˆˆ x âˆ§ z âˆˆ y)'
assume difference: 'âˆ€ x, y, z. z âˆˆ x âˆ– y = (z âˆˆ x âˆ§ z âˆ‰ y)'
assume subset: 'âˆ€ x, y. x âŠ‚ y = (âˆ€ z âˆˆ x. z âˆˆ y)'
assume singleton: 'âˆ€ x, y. y âˆˆ {x} = (y = x)'
assume power: 'âˆ€ x, y. x âˆˆ ğ’« y = x âŠ‚ y'
assume repl: 'âˆ€ A, f, b. b âˆˆ repl A f = (âˆƒ a âˆˆ A. b = f a)'
assume sep: 'âˆ€ A, p, a. a âˆˆ sep A p = (a âˆˆ A âˆ§ p a)'
assume regularity: 'âˆ€ A. A â‰  âˆ… â†’ (âˆƒ x âˆˆ A. x âˆ© A = âˆ…)'
assume infinity: 'âˆƒ X. âˆ… âˆˆ X âˆ§ (âˆ€ x âˆˆ X. x âˆª {x} âˆˆ X)'
assume forallin: 'âˆ€ X, P. forallin X P = (âˆ€ x. x âˆˆ X â†’ P x)'
assume existsin: 'âˆ€ X, P. existsin X P = (âˆƒ x. x âˆˆ X âˆ§ P x)'
assume pair: 'âˆ€ x, y. (x, y) = {{x}, {x, y}}'
assume fun: 'âˆ€ X, f. fun X f = {(x, f x)| x âˆˆ X}'
assume apply: 'âˆ€ X, f, x âˆˆ X. fun X f x = f x'
